import{_ as t,c as e,o as n,a as o}from"./app.13d6c113.js";const _=JSON.parse('{"title":"Routing","description":"","frontmatter":{},"headers":[],"relativePath":"guide/routing.md"}'),a={name:"guide/routing.md"},s=o(`<h1 id="routing" tabindex="-1">Routing <a class="header-anchor" href="#routing" aria-hidden="true">#</a></h1><p><strong>Routing</strong> refers to the process of determining how an application should respond to an incoming client request on a particular endpoint, which is identified by a URI (or path) and a HTTP method (GET, POST, ...).</p><p>Each endpoint aka path can have one or more handler functions, which are executed when the route (&amp; method) is matched.</p><p>A route definition has the following structure:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">router.METHOD(PATH, HANDLER)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Where:</p><ul><li><strong>router</strong> represents a router instance</li><li><strong>METHOD</strong> the HTTP method (get, post, ...) in lowercase or the <code>use</code> method to respond to any HTTP method.</li><li><strong>PATH</strong> defines the endpoint and the mount path of the handler</li><li><strong>HANDLER</strong> is a function, which is executed when the route matches</li></ul><p>Routing methods can have <strong>more</strong> than one callback function as argument. In this case it is important, that if a callback function will not handle the request, it should pass the task to the next callback function in the chain, by calling the <strong>next()</strong> function argument of a handler.</p>`,8),i=[s];function r(c,h,l,d,p,u){return n(),e("div",null,i)}const m=t(a,[["render",r]]);export{_ as __pageData,m as default};
